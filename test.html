<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Waveform Player Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 40px;
            background-color: #1e1e1e;
            color: #dcddde;
            line-height: 1.6;
        }

        h1 {
            color: #7c3aed;
            margin-bottom: 30px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .audio-player-test {
            margin: 20px 0;
            padding: 20px;
            background-color: #2f3136;
            border-radius: 8px;
            border: 1px solid #40444b;
        }

        /* CSS Variables to match Obsidian theme */
        :root {
            --background-primary: #2f3136;
            --background-modifier-border: #40444b;
            --text-muted: #b9bbbe;
            --text-accent: #7c3aed;
            --font-interface: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        .instructions {
            background-color: #36393f;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #7c3aed;
        }

        .console-output {
            background-color: #000;
            color: #00ff00;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
            border: 1px solid #333;
        }

        .file-input {
            margin: 15px 0;
            padding: 10px;
            background-color: #36393f;
            border: 1px solid #40444b;
            border-radius: 4px;
        }

        .file-input input[type="file"] {
            color: #dcddde;
            background-color: #40444b;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 8px;
        }

        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-weight: bold;
        }

        .status.success {
            background-color: #1f4e4e;
            color: #4ade80;
            border: 1px solid #22c55e;
        }

        .status.error {
            background-color: #4e1f1f;
            color: #f87171;
            border: 1px solid #ef4444;
        }

        .status.warning {
            background-color: #4e3e1f;
            color: #fbbf24;
            border: 1px solid #f59e0b;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎵 Audio Waveform Player Test</h1>
        
        <div class="instructions">
            <h3>Instructions:</h3>
            <ol>
                <li>Select an audio file below (MP3, WAV, etc.)</li>
                <li>The player will load and show the waveform</li>
                <li>Click the speed icon to show the speed slider</li>
                <li>Move the speed slider to test Rubber Band time stretching</li>
                <li>Check the console output below for debugging info</li>
            </ol>
            <p><strong>Note:</strong> Make sure your audio files are named with "-guitar" or "-no-guitar" patterns for the guitar switching feature to work properly.</p>
        </div>

        <div class="file-input">
            <label for="audioFile">Select Audio File:</label>
            <input type="file" id="audioFile" accept="audio/*">
        </div>

        <div id="status"></div>

        <div class="audio-player-test">
            <div id="audioPlayerContainer">
                <!-- Audio player will be inserted here -->
            </div>
        </div>

        <h3>Console Output:</h3>
        <div id="consoleOutput" class="console-output">
            Console messages will appear here...
        </div>
    </div>

    <script type="module">
        // Mock Obsidian objects for browser testing
        window.TFile = class TFile {
            constructor(path) {
                this.path = path;
                this.name = path.split('/').pop();
            }
        };

        // Mock Obsidian app
        const mockApp = {
            vault: {
                getAbstractFileByPath: (path) => {
                    // In browser, we'll handle files differently
                    return null;
                },
                readBinary: async (file) => {
                    // This won't be used in browser mode
                    return new ArrayBuffer(0);
                }
            }
        };

        // Mock Component class
        class Component {
            constructor() {
                this.load = () => {};
                this.unload = () => {};
            }
        }

        // Console capture for display
        const consoleOutput = document.getElementById('consoleOutput');
        const originalConsole = {
            log: console.log,
            warn: console.warn,
            error: console.error
        };

        function addToConsole(type, ...args) {
            const timestamp = new Date().toLocaleTimeString();
            const message = args.map(arg => 
                typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
            ).join(' ');
            
            const color = {
                log: '#00ff00',
                warn: '#ffff00',
                error: '#ff4444'
            }[type] || '#00ff00';
            
            consoleOutput.innerHTML += `<div style="color: ${color}">[${timestamp}] ${type.toUpperCase()}: ${message}</div>`;
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
            
            // Call original console method
            originalConsole[type](...args);
        }

        console.log = (...args) => addToConsole('log', ...args);
        console.warn = (...args) => addToConsole('warn', ...args);
        console.error = (...args) => addToConsole('error', ...args);

        // Import Rubber Band WASM library for high-quality time stretching
        let RubberBandModule = null;

        // Dynamically import the Rubber Band library
        async function loadRubberBand() {
            if (!RubberBandModule) {
                console.log('Attempting to load Rubber Band WASM library...');
                
                // Method 1: Try loading local files directly
                try {
                    console.log('Method 1: Trying to load local rubberband.js file...');
                    
                    // Try different local paths
                    const localPaths = [
                        './node_modules/@echogarden/rubberband-wasm/rubberband.js',
                        'http://localhost:8080/node_modules/@echogarden/rubberband-wasm/rubberband.js',
                        '/node_modules/@echogarden/rubberband-wasm/rubberband.js'
                    ];
                    
                    let module = null;
                    let lastError = null;
                    
                    for (const path of localPaths) {
                        try {
                            console.log(`Attempting to import: ${path}`);
                            module = await import(path);
                            console.log(`Successfully imported from: ${path}`);
                            break;
                        } catch (pathError) {
                            console.log(`Failed to import from ${path}:`, pathError.message);
                            lastError = pathError;
                        }
                    }
                    
                    if (!module) {
                        throw lastError || new Error('All local paths failed');
                    }
                    
                    console.log('Local module imported successfully, module:', module);
                    console.log('Module.default type:', typeof module.default);
                    
                    if (typeof module.default === 'function') {
                        console.log('Calling module.default() to initialize WASM...');
                        RubberBandModule = await module.default();
                        console.log('Rubber Band WASM initialized from local files successfully');
                        console.log('RubberBandModule type:', typeof RubberBandModule);
                        console.log('RubberBandModule keys:', Object.keys(RubberBandModule));
                        return RubberBandModule;
                    } else {
                        throw new Error(`Module.default is not a function, got: ${typeof module.default}`);
                    }
                } catch (localError) {
                    console.warn('Method 1 failed - Could not load Rubber Band locally:');
                    console.warn('Error name:', localError.name);
                    console.warn('Error message:', localError.message);
                    console.warn('Error stack:', localError.stack);
                    
                    // Method 2: Try CDN with fetch
                    try {
                        console.log('Method 2: Trying CDN with fetch...');
                        const cdnUrl = 'https://cdn.jsdelivr.net/npm/@echogarden/rubberband-wasm@0.2.0/rubberband.js';
                        console.log(`Fetching from CDN: ${cdnUrl}`);
                        
                        const response = await fetch(cdnUrl);
                        console.log('CDN response status:', response.status);
                        console.log('CDN response headers:', [...response.headers.entries()]);
                        
                        if (!response.ok) {
                            throw new Error(`CDN fetch failed with status ${response.status}: ${response.statusText}`);
                        }
                        
                        const moduleText = await response.text();
                        console.log('CDN module text length:', moduleText.length);
                        console.log('CDN module text start:', moduleText.substring(0, 200));
                        
                        const blob = new Blob([moduleText], { type: 'application/javascript' });
                        const moduleUrl = URL.createObjectURL(blob);
                        console.log('Created blob URL:', moduleUrl);
                        
                        const module = await import(moduleUrl);
                        console.log('CDN module imported, module:', module);
                        console.log('CDN Module.default type:', typeof module.default);
                        
                        URL.revokeObjectURL(moduleUrl);
                        
                        if (typeof module.default === 'function') {
                            console.log('Calling CDN module.default() to initialize WASM...');
                            RubberBandModule = await module.default();
                            console.log('Rubber Band WASM loaded from CDN successfully');
                            console.log('CDN RubberBandModule type:', typeof RubberBandModule);
                            console.log('CDN RubberBandModule keys:', Object.keys(RubberBandModule));
                            return RubberBandModule;
                        } else {
                            throw new Error(`CDN Module.default is not a function, got: ${typeof module.default}`);
                        }
                    } catch (cdnError) {
                        console.error('Method 2 failed - Could not load Rubber Band from CDN:');
                        console.error('CDN Error name:', cdnError.name);
                        console.error('CDN Error message:', cdnError.message);
                        console.error('CDN Error stack:', cdnError.stack);
                        
                        // Method 3: Try direct script tag approach
                        try {
                            console.log('Method 3: Trying direct script tag approach...');
                            return await loadRubberBandViaScript();
                        } catch (scriptError) {
                            console.error('Method 3 failed - Script tag approach failed:');
                            console.error('Script Error name:', scriptError.name);
                            console.error('Script Error message:', scriptError.message);
                            console.error('Script Error stack:', scriptError.stack);
                            
                            console.error('All methods failed. Final error summary:');
                            console.error('1. Local import error:', localError.message);
                            console.error('2. CDN fetch error:', cdnError.message);
                            console.error('3. Script tag error:', scriptError.message);
                        }
                    }
                }
            }
            return RubberBandModule;
        }

        // Alternative loading method using script tag
        function loadRubberBandViaScript() {
            return new Promise((resolve, reject) => {
                console.log('Creating script tag for Rubber Band...');
                const script = document.createElement('script');
                script.type = 'module';
                script.textContent = `
                    import Rubberband from 'https://cdn.jsdelivr.net/npm/@echogarden/rubberband-wasm@0.2.0/rubberband.js';
                    
                    (async () => {
                        try {
                            console.log('Script tag: Initializing Rubber Band...');
                            const module = await Rubberband();
                            console.log('Script tag: Rubber Band initialized');
                            window.RubberBandModuleGlobal = module;
                            window.dispatchEvent(new CustomEvent('rubberband-loaded'));
                        } catch (error) {
                            console.error('Script tag: Error initializing Rubber Band:', error);
                            window.dispatchEvent(new CustomEvent('rubberband-error', { detail: error }));
                        }
                    })();
                `;
                
                document.head.appendChild(script);
                
                const timeout = setTimeout(() => {
                    reject(new Error('Script tag loading timeout after 10 seconds'));
                }, 10000);
                
                window.addEventListener('rubberband-loaded', () => {
                    clearTimeout(timeout);
                    console.log('Script tag method succeeded');
                    RubberBandModule = window.RubberBandModuleGlobal;
                    resolve(RubberBandModule);
                }, { once: true });
                
                window.addEventListener('rubberband-error', (event) => {
                    clearTimeout(timeout);
                    reject(new Error(`Script tag method failed: ${event.detail.message}`));
                }, { once: true });
                
                script.onerror = (error) => {
                    clearTimeout(timeout);
                    reject(new Error(`Script tag failed to load: ${error.message || 'Unknown error'}`));
                };
            });
        }

        // Audio Player Component (simplified for browser)
        class AudioWaveformPlayerComponent extends Component {
            constructor(container, config, app) {
                super();
                this.container = container;
                this.config = config;
                this.app = app;
                this.audioContext = null;
                this.audioBuffer = null;
                this.waveformData = null;
                this.isPlaying = false;
                this.isLooping = false;
                this.animationFrame = null;
                this.waveformBars = [];
                this.lastCurrentTime = 0;
                this.hasGuitar = true;
                this.guitarVersion = null;
                this.noGuitarVersion = null;
                this.primaryAudio = null;
                this.secondaryAudio = null;
                this.currentAudio = null;
                this.isTransitioning = false;
                this.isSpeedSliderVisible = false;
                this.playbackSpeed = 100;
                this.isDraggingSpeedSlider = false;
                
                // Rubber Band time stretching properties
                this.rubberBandModule = null;
                this.stretchedAudioBuffer = null;
                this.stretchedAudioUrl = null;
                this.currentTimeRatio = 1.0;
                this.currentPitchRatio = 1.0;
                this.isTimeStretchingEnabled = false;
                this.originalAudioBuffer = null;
            }

            async render() {
                // Use the same HTML structure as the Obsidian version
                this.container.innerHTML = `
                    <div class="audio-player-wrapper" style="padding: 10px; flex-direction: column; justify-content: flex-start; align-items: flex-start; gap: 25px; display: flex; width: ${this.config.width || 500}px; margin: 0 auto;">
                        <div class="audio-player-frame" style="padding: 21px 24px 12px 24px; background: var(--background-primary); border: 1px solid var(--background-modifier-border); box-shadow: 0px 4px 4px rgba(0, 0, 0, 0.25); border-radius: 11px; flex-direction: column; justify-content: flex-start; align-items: center; gap: 27px; display: flex; width: 100%;">
                            <div class="waveform-container" style="position: relative; cursor: pointer; width: 100%;">
                                <svg width="447" height="34" viewBox="0 0 447 34" fill="none" xmlns="http://www.w3.org/2000/svg" class="waveform-svg" style="width: 100%; height: 34px;">
                                    <!-- Waveform will be generated here -->
                                </svg>
                                <div class="playhead" style="position: absolute; top: 0; left: 0; width: 2px; height: 34px; background: var(--text-accent); transition: left 0.1s ease-out; display: none;"></div>
                            </div>
                            <div class="controls" style="align-self: stretch; justify-content: space-between; align-items: center; display: inline-flex;">
                                <div class="volume-icon" style="cursor: pointer; transition: opacity 0.2s ease;">
                                    <svg width="11" height="10" viewBox="0 0 11 10" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M8.25004 9.44682C8.25004 9.89572 7.74447 10.1571 7.38045 9.89637L4.53963 7.85937L8.25004 4.96316V9.44682ZM7.38045 0.103793C7.74447 -0.157125 8.25001 0.103885 8.25004 0.552806V3.56437L2.87565 7.75965H2.74996C2.14244 7.75965 1.64995 7.2654 1.64995 6.65572V3.34391C1.65002 2.73428 2.14248 2.23997 2.74996 2.23997H4.39998L7.38045 0.103793Z" fill="var(--text-muted)"/>
                                        <path d="M10.1122 0.700637C10.3519 0.513529 10.6975 0.556659 10.8841 0.797123C11.0705 1.03769 11.0275 1.38452 10.7879 1.57171L0.887776 9.29926C0.648064 9.48637 0.302464 9.44324 0.115939 9.20278C-0.0705037 8.96221 -0.0275275 8.61538 0.212083 8.42819L10.1122 0.700637Z" fill="var(--text-muted)"/>
                                    </svg>
                                </div>
                                <div class="guitar-icon" style="cursor: pointer; transition: opacity 0.2s ease;">
                                    <svg width="16" height="20" viewBox="0 0 16 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path fill-rule="evenodd" clip-rule="evenodd" d="M14.7847 0.49309C14.5675 0.779052 14.1588 1.21574 13.8764 1.4636C13.4064 1.87609 13.3586 1.95132 13.3115 2.35413C13.2642 2.75932 13.012 3.15042 10.12 7.30558C8.39296 9.78694 6.93503 11.8649 6.88014 11.9232C6.7396 12.0729 6.10327 11.7734 5.90262 11.4632C5.76035 11.2433 5.75905 11.1909 5.88378 10.7192C5.97029 10.3923 5.98983 10.1608 5.93884 10.0686C5.80994 9.83516 5.38798 9.89455 5.0521 10.1933C4.73072 10.4791 4.30546 11.2495 4.30407 11.5484C4.30268 11.8526 3.9079 12.6092 3.64325 12.815C3.50557 12.922 3.03349 13.2473 2.59416 13.5376C2.15491 13.828 1.65183 14.2328 1.47637 14.4371C0.823191 15.1975 0.588585 16.0722 0.862451 16.7253C1.26252 17.679 2.62717 18.9626 3.95151 19.6306C4.63127 19.9735 4.73454 20 5.39094 20C6.00607 20 6.16407 19.9657 6.60514 19.736C6.96404 19.5491 7.19526 19.3496 7.39669 19.0528C7.68098 18.6338 7.73509 18.4395 8.08817 16.5685C8.31157 15.3847 8.38141 15.2558 8.96736 14.9474C9.7484 14.5363 10.1101 14.1409 10.2814 13.5109C10.4966 12.7192 10.0529 12.2188 9.12562 12.2071C8.16192 12.1952 8.11388 12.3485 9.93792 9.61527C14.0543 3.44686 13.9824 3.54848 14.257 3.51874C14.3967 3.50361 14.556 3.43199 14.6111 3.35948C14.6766 3.27334 14.7311 3.25997 14.7682 3.32095C14.8637 3.47739 14.9886 3.42512 14.9886 3.22882C14.9886 3.10018 14.9487 3.05892 14.8583 3.09411C14.7705 3.12816 14.728 3.08989 14.728 2.97673C14.728 2.77991 14.8652 2.66719 14.9452 2.79829C15.0183 2.91822 15.1623 2.82337 15.1623 2.65523C15.1623 2.56442 15.1097 2.53943 14.9958 2.57604C14.8615 2.61915 14.8382 2.59531 14.8749 2.45268C14.9043 2.339 14.9836 2.28268 15.097 2.29509C15.194 2.30565 15.2908 2.26491 15.312 2.20437C15.3348 2.13909 15.277 2.09439 15.1695 2.09439C14.9707 2.09439 14.9479 2.03042 15.0755 1.83042C15.1316 1.74244 15.1601 1.73513 15.161 1.80843C15.1617 1.86896 15.221 1.91841 15.2926 1.91841C15.3672 1.91841 15.4229 1.83913 15.4229 1.73302C15.4229 1.60438 15.383 1.56312 15.2926 1.59831C15.204 1.63271 15.1623 1.59356 15.1623 1.47574C15.1623 1.28736 15.29 1.24389 15.3852 1.3999C15.4266 1.46774 15.4672 1.46114 15.5193 1.3779C15.6371 1.18961 15.6106 1.12652 15.4136 1.12652C15.2825 1.12652 15.2455 1.0871 15.2833 0.98732C15.3123 0.910771 15.336 0.826742 15.336 0.80061C15.336 0.774389 15.3963 0.803689 15.47 0.865633C15.5652 0.945702 15.6309 0.950981 15.6969 0.88411C15.8192 0.760223 15.713 0.592605 15.552 0.655253C15.4537 0.69344 15.4305 0.630616 15.4462 0.368851C15.4781 -0.16207 15.2499 -0.119132 14.7847 0.49309ZM7.00626 12.944C7.65952 13.4186 7.75924 13.5753 7.50952 13.7348C7.40094 13.8041 7.22306 13.7198 6.70607 13.3542C6.03456 12.8793 5.95787 12.7735 6.14635 12.5826C6.29679 12.4302 6.30183 12.4322 7.00626 12.944ZM4.03524 13.6537C4.1518 13.7959 4.07389 14.0608 3.91537 14.0608C3.85475 14.0608 3.75642 14.0014 3.69692 13.9288C3.61067 13.8235 3.61067 13.7702 3.69692 13.6648C3.83095 13.5013 3.90825 13.4987 4.03524 13.6537ZM5.74254 14.8747C6.09615 15.1287 6.38634 15.371 6.38747 15.4131C6.3893 15.4799 5.52235 16.7948 5.34464 16.9948C5.28679 17.0599 3.93787 16.1779 3.83347 16.0067C3.77041 15.9034 4.83877 14.4127 4.97584 14.4127C5.04393 14.4127 5.38894 14.6207 5.74254 14.8747ZM3.30606 14.8087C3.30606 15.012 3.01334 15.1016 2.90885 14.9303C2.81843 14.782 2.98659 14.5728 3.16778 14.6082C3.24387 14.6229 3.30606 14.7132 3.30606 14.8087ZM2.50426 15.4906C2.56593 15.6695 2.47377 15.8206 2.30301 15.8206C2.11148 15.8206 2.01333 15.6834 2.07961 15.5084C2.13885 15.352 2.45206 15.3389 2.50426 15.4906Z" fill="var(--text-muted)"/>
                                    </svg>
                                </div>
                                <div class="play-pause" style="padding-left: 32px; padding-right: 32px; justify-content: flex-start; align-items: center; gap: 71px; display: flex;">
                                    <div class="play-btn" style="cursor: pointer;">
                                        <svg width="20" height="24" viewBox="0 0 20 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                            <path d="M18.9091 13.1064C19.697 12.5954 19.697 11.4046 18.9091 10.8936L2.42348 0.200406C1.58614 -0.342724 0.5 0.282035 0.5 1.30681V22.6932C0.5 23.718 1.58614 24.3427 2.42348 23.7996L18.9091 13.1064Z" fill="var(--text-muted)"/>
                                        </svg>
                                    </div>
                                    <div class="pause-btn" style="cursor: pointer; display: none;">
                                        <svg width="20" height="24" viewBox="0 0 11 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                                            <path d="M0 1.33333C0 0.596954 0.615609 0 1.375 0H2.75C3.50939 0 4.125 0.596954 4.125 1.33333V10.6667C4.125 11.403 3.50939 12 2.75 12H1.375C0.615608 12 0 11.403 0 10.6667V1.33333Z" fill="var(--text-muted)"/>
                                            <path d="M6.875 1.33333C6.875 0.596954 7.49061 0 8.25 0H9.625C10.3844 0 11 0.596954 11 1.33333V10.6667C11 11.403 10.3844 12 9.625 12H8.25C7.49061 12 6.875 11.403 6.875 10.6667V1.33333Z" fill="var(--text-muted)"/>
                                        </svg>
                                    </div>
                                </div>
                                <div class="loop-btn" style="cursor: pointer; opacity: 0.6;">
                                    <svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M2.34374 6.60969C2.34374 4.75107 3.8129 3.24437 5.62519 3.24437H8.35973M10.5474 7.17057C10.5474 9.02919 9.07821 10.5359 7.26592 10.5359H4.53138M8.35973 5.14669V1.56178C8.35973 1.12124 8.83223 0.852667 9.1965 1.08615L11.993 2.87861C12.3357 3.09829 12.3357 3.61019 11.993 3.82987L9.1965 5.62232C8.83223 5.85581 8.35973 5.58723 8.35973 5.14669ZM5.14027 12.4382V8.85331C5.14027 8.41277 4.66777 8.14419 4.3035 8.37768L1.50705 10.1701C1.16432 10.3898 1.16432 10.9017 1.50705 11.1214L4.3035 12.9138C4.66777 13.1473 5.14027 12.8788 5.14027 12.4382Z" stroke="var(--text-muted)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                </div>
                                <div class="speed-icon" style="cursor: pointer; opacity: 0.6;">
                                    <svg width="14" height="10" viewBox="0 0 14 10" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M5.23529 8.6C5.23529 8.33736 5.28094 8.07728 5.36962 7.83463C5.45831 7.59198 5.5883 7.3715 5.75216 7.18579C5.91603 7.00007 6.11057 6.85275 6.32468 6.75224C6.53878 6.65173 6.76826 6.6 7 6.6C7.23175 6.6 7.46122 6.65173 7.67532 6.75224C7.88943 6.85275 8.08397 7.00007 8.24784 7.18579C8.4117 7.3715 8.54169 7.59198 8.63038 7.83463C8.71906 8.07729 8.76471 8.33736 8.76471 8.6M8.05882 6.6L9.47059 4.2M1 7.8C1 6.90701 1.15519 6.02277 1.45672 5.19775C1.75825 4.37274 2.20021 3.62311 2.75736 2.99167C3.31451 2.36023 3.97595 1.85935 4.7039 1.51762C5.43186 1.17589 6.21207 1 7 1C7.78793 1 8.56815 1.17589 9.2961 1.51762C10.0241 1.85935 10.6855 2.36024 11.2426 2.99168C11.7998 3.62312 12.2418 4.37274 12.5433 5.19776C12.8448 6.02277 13 6.90702 13 7.8V8.2C13 8.64183 12.684 9 12.2941 9H1.70588C1.31603 9 1 8.64183 1 8.2L1 7.8Z" stroke="var(--text-muted)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                </div>
                            </div>
                        </div>
                        <div class="playback-speed-wrapper" style="align-self: stretch; height: 47px; flex-direction: column; justify-content: space-between; align-items: center; display: none;">
                            <div class="playback-speed-menu" style="padding: 15px; background: var(--background-primary); box-shadow: 0px 4px 3.4px rgba(0, 0, 0, 0.25); border-radius: 4px; justify-content: flex-start; align-items: center; gap: 10px; display: inline-flex; position: relative;">
                                <div class="playback-speed-slider-container" style="position: relative; width: 211px; height: 13px; display: flex; align-items: center;">
                                    <div class="slider-rail" style="position: absolute; left: 1.5px; right: 1.5px; height: 3px; background: var(--text-muted); border-radius: 1.5px;"></div>
                                    <div class="playback-speed-slider-grabber" style="position: absolute; left: 126px; width: 14px; height: 14px; transform: translateX(-50%); cursor: grab;">
                                        <div style="width: 13px; height: 13px; background: #6586B3; border-radius: 50%; border: 0.5px solid #5a75a0;"></div>
                                    </div>
                                </div>
                                <div class="playback-speed-indicator" style="color: var(--text-muted); font-size: 10px; font-family: var(--font-interface); font-weight: 400;">100%</div>
                            </div>
                        </div>
                    </div>
                    <audio preload="auto" style="display: none;" class="primary-audio"></audio>
                    <audio preload="auto" style="display: none;" class="secondary-audio"></audio>
                `;

                // Get references to elements
                this.primaryAudio = this.container.querySelector('.primary-audio');
                this.secondaryAudio = this.container.querySelector('.secondary-audio');
                this.currentAudio = this.primaryAudio;
                this.audio = this.currentAudio;
                this.waveformSvg = this.container.querySelector('.waveform-svg');
                this.waveformContainer = this.container.querySelector('.waveform-container');
                this.playhead = this.container.querySelector('.playhead');
                this.playBtn = this.container.querySelector('.play-btn');
                this.pauseBtn = this.container.querySelector('.pause-btn');
                this.loopBtn = this.container.querySelector('.loop-btn');
                this.guitarIcon = this.container.querySelector('.guitar-icon');
                this.speedIcon = this.container.querySelector('.speed-icon');
                this.speedSliderWrapper = this.container.querySelector('.playback-speed-wrapper');
                this.speedSliderGrabber = this.container.querySelector('.playback-speed-slider-grabber');
                this.speedSliderContainer = this.container.querySelector('.playback-speed-slider-container');
                this.speedIndicator = this.container.querySelector('.playback-speed-indicator');

                // Set up the audio source
                await this.setupAudio();
                this.setupEventListeners();
                await this.loadAudioData();
                this.generateWaveform();
                
                // Initialize speed slider position for 100%
                this.updateSpeedSliderPosition();
            }

            // Include all the methods from the main component
            // Copy the key methods here (setupAudio, setupEventListeners, etc.)
            // For brevity, including only essential methods for time stretching testing

            async setupAudio() {
                if (this.config.src) {
                    this.primaryAudio.src = this.config.src;
                    this.secondaryAudio.src = this.config.src;
                    
                    // Detect versions for guitar switching
                    this.guitarVersion = this.config.src;
                    this.noGuitarVersion = this.config.src.replace('-guitar', '-no-guitar');
                    this.hasGuitar = this.config.src.includes('-guitar');
                    
                    this.updateGuitarIconState();
                    this.updateSpeedIconState();
                }
            }

            setupEventListeners() {
                this.playBtn.addEventListener('click', () => this.play());
                this.pauseBtn.addEventListener('click', () => this.pause());
                this.speedIcon.addEventListener('click', () => this.toggleSpeedSlider());
                
                // Speed slider functionality
                this.speedSliderGrabber.addEventListener('mousedown', (e) => {
                    this.isDraggingSpeedSlider = true;
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.isDraggingSpeedSlider) {
                        const rect = this.speedSliderContainer.getBoundingClientRect();
                        const mouseX = e.clientX - rect.left;
                        const progress = Math.max(0, Math.min(1, mouseX / rect.width));
                        
                        this.playbackSpeed = Math.round(40 + (progress * 85));
                        this.updateSpeedSliderPosition();
                        this.updateSpeedIndicator();
                        console.log(`Speed slider moved to: ${this.playbackSpeed}%`);
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (this.isDraggingSpeedSlider) {
                        this.isDraggingSpeedSlider = false;
                        this.updateTimeStretching();
                    }
                });
            }

            async loadAudioData() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    await this.loadAudioForWaveform();
                    await this.initializeRubberBand();
                } catch (error) {
                    console.error('Error loading audio for waveform:', error);
                }
            }

            async loadAudioForWaveform() {
                return new Promise((resolve) => {
                    const xhr = new XMLHttpRequest();
                    xhr.open('GET', this.currentAudio.src, true);
                    xhr.responseType = 'arraybuffer';
                    
                    xhr.onload = async () => {
                        if (xhr.status === 200 || xhr.status === 0) {
                            try {
                                if (this.audioContext) {
                                    this.audioBuffer = await this.audioContext.decodeAudioData(xhr.response);
                                    this.originalAudioBuffer = this.audioBuffer;
                                    this.waveformData = this.audioBuffer.getChannelData(0);
                                }
                                resolve();
                            } catch (e) {
                                console.warn('Could not decode audio data for waveform');
                                resolve();
                            }
                        } else {
                            resolve();
                        }
                    };
                    
                    xhr.onerror = () => resolve();
                    xhr.send();
                });
            }

            async initializeRubberBand() {
                try {
                    const RubberBandModule = await loadRubberBand();
                    if (!RubberBandModule || !this.audioBuffer) {
                        console.warn('Rubber Band module or audio buffer not available');
                        return;
                    }

                    console.log('Rubber Band module loaded successfully for time stretching');

                    this.originalAudioBuffer = this.audioBuffer;
                    this.isTimeStretchingEnabled = true;
                    this.rubberBandModule = RubberBandModule;

                    console.log('Time stretching available - will be applied when speed is not 100%');
                } catch (error) {
                    console.error('Error initializing Rubber Band:', error);
                    this.isTimeStretchingEnabled = false;
                }
            }

            generateWaveform() {
                if (!this.waveformData) return;

                const svgWidth = 447;
                const svgHeight = 34;
                const samples = 200;
                const barWidth = 2.235;

                this.waveformSvg.innerHTML = '';
                this.waveformBars = [];

                const samplesPerBar = Math.floor(this.waveformData.length / samples);

                for (let i = 0; i < samples; i++) {
                    let sum = 0;
                    let count = 0;

                    for (let j = 0; j < samplesPerBar; j++) {
                        const index = i * samplesPerBar + j;
                        if (index < this.waveformData.length) {
                            sum += Math.abs(this.waveformData[index]);
                            count++;
                        }
                    }

                    const average = count > 0 ? sum / count : 0;
                    const barHeight = Math.max(1, average * svgHeight * 2);
                    const x = i * barWidth;
                    const y = (svgHeight - barHeight) / 2;

                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', x.toString());
                    rect.setAttribute('y', y.toString());
                    rect.setAttribute('width', (barWidth - 0.5).toString());
                    rect.setAttribute('height', barHeight.toString());
                    rect.setAttribute('fill', 'var(--text-muted)');
                    rect.setAttribute('fill-opacity', '0.6');

                    this.waveformSvg.appendChild(rect);
                    this.waveformBars.push(rect);
                }
            }

            play() {
                this.currentAudio.play();
                this.isPlaying = true;
                this.playBtn.style.display = 'none';
                this.pauseBtn.style.display = 'block';
                this.playhead.style.display = 'block';
            }

            pause() {
                this.currentAudio.pause();
                this.isPlaying = false;
                this.playBtn.style.display = 'block';
                this.pauseBtn.style.display = 'none';
            }

            toggleSpeedSlider() {
                this.isSpeedSliderVisible = !this.isSpeedSliderVisible;
                this.speedSliderWrapper.style.display = this.isSpeedSliderVisible ? 'flex' : 'none';
                this.updateSpeedIconState();
            }

            updateSpeedIconState() {
                if (this.speedIcon) {
                    this.speedIcon.style.opacity = this.isSpeedSliderVisible ? '1' : '0.6';
                }
            }

            updateSpeedSliderPosition() {
                if (this.speedSliderGrabber && this.speedSliderContainer) {
                    const progress = (this.playbackSpeed - 40) / 85;
                    const containerWidth = 211;
                    const position = progress * containerWidth;
                    this.speedSliderGrabber.style.left = `${position}px`;
                }
            }

            updateSpeedIndicator() {
                if (this.speedIndicator) {
                    this.speedIndicator.textContent = `${this.playbackSpeed}%`;
                }
            }

            updateGuitarIconState() {
                if (this.guitarIcon) {
                    this.guitarIcon.style.opacity = this.hasGuitar ? '1' : '0.4';
                }
            }

            // Time stretching methods
            async updateTimeStretching() {
                console.log(`updateTimeStretching called: speed=${this.playbackSpeed}%, enabled=${this.isTimeStretchingEnabled}, hasBuffer=${!!this.originalAudioBuffer}, hasModule=${!!this.rubberBandModule}`);
                
                if (!this.isTimeStretchingEnabled || !this.originalAudioBuffer || !this.rubberBandModule) {
                    console.log('Time stretching not enabled or components not available');
                    return;
                }

                if (this.playbackSpeed === 100) {
                    console.log('Speed at 100% - using original audio');
                    this.currentAudio.src = this.primaryAudio.src;
                    return;
                }

                const timeRatio = this.playbackSpeed / 100;
                console.log(`Processing time stretching with ratio: ${timeRatio} (${this.playbackSpeed}%)`);
                
                try {
                    const stretchedBuffer = await this.processTimeStretching(this.originalAudioBuffer, timeRatio);
                    if (stretchedBuffer) {
                        const wavData = this.audioBufferToWav(stretchedBuffer);
                        const blob = new Blob([wavData], { type: 'audio/wav' });
                        
                        // Clean up previous URL
                        if (this.stretchedAudioUrl) {
                            URL.revokeObjectURL(this.stretchedAudioUrl);
                        }
                        
                        this.stretchedAudioUrl = URL.createObjectURL(blob);
                        this.currentAudio.src = this.stretchedAudioUrl;
                        
                        console.log('Time stretching applied successfully');
                    }
                } catch (error) {
                    console.error('Error applying time stretching:', error);
                }
            }

            async processTimeStretching(audioBuffer, timeRatio) {
                console.log(`processTimeStretching: timeRatio=${timeRatio}, channels=${audioBuffer.numberOfChannels}, length=${audioBuffer.length}`);
                
                if (!this.rubberBandModule) {
                    console.error('Rubber Band module not available');
                    return null;
                }

                try {
                    const channels = audioBuffer.numberOfChannels;
                    const sampleRate = audioBuffer.sampleRate;
                    const inputLength = audioBuffer.length;
                    
                    console.log('Creating new Rubber Band stretcher instance...');
                    
                    // Create a fresh stretcher instance for each operation
                    const OptionProcessOffline = 0x00000000;
                    const OptionStretchPrecise = 0x00000010;
                    const OptionTransientsMixed = 0x00000100;
                    const OptionDetectorCompound = 0x00000000;
                    const OptionPhaseLaminar = 0x00000000;
                    const OptionWindowStandard = 0x00000000;
                    const OptionSmoothingOn = 0x00800000;
                    const OptionFormantPreserved = 0x01000000;
                    const OptionPitchHighQuality = 0x02000000;
                    const OptionChannelsTogether = 0x10000000;

                    const options = OptionProcessOffline | 
                                  OptionStretchPrecise | 
                                  OptionTransientsMixed | 
                                  OptionDetectorCompound | 
                                  OptionPhaseLaminar | 
                                  OptionWindowStandard | 
                                  OptionSmoothingOn | 
                                  OptionFormantPreserved | 
                                  OptionPitchHighQuality | 
                                  OptionChannelsTogether;

                    const stretcher = this.rubberBandModule._rubberband_new(
                        sampleRate,
                        channels,
                        options,
                        timeRatio,
                        1.0  // pitch ratio
                    );

                    if (stretcher === 0) {
                        console.error('Failed to create new Rubber Band stretcher');
                        return null;
                    }
                    
                    console.log(`Created stretcher with time ratio: ${timeRatio} and pitch scale: 1.0`);
                    
                    // Calculate expected output length
                    const outputLength = Math.ceil(inputLength * timeRatio);
                    
                    console.log(`Input length: ${inputLength}, Output length: ${outputLength}`);
                    
                    // Prepare input data
                    const inputData = [];
                    for (let c = 0; c < channels; c++) {
                        inputData.push(audioBuffer.getChannelData(c));
                    }
                    
                    console.log('Allocating WASM memory...');
                    
                    // Allocate memory for input data (separate allocation for each channel)
                    const inputPtrs = this.rubberBandModule._malloc(channels * 4); // Array of pointers
                    const inputChannelPtrs = [];
                    
                    for (let c = 0; c < channels; c++) {
                        const channelPtr = this.rubberBandModule._malloc(inputLength * 4); // 4 bytes per float
                        inputChannelPtrs.push(channelPtr);
                        this.rubberBandModule.HEAPU32[inputPtrs / 4 + c] = channelPtr;
                        
                        // Copy channel data to WASM memory
                        console.log(`Copying channel ${c} data to WASM memory...`);
                        for (let i = 0; i < inputLength; i++) {
                            this.rubberBandModule.HEAPF32[channelPtr / 4 + i] = inputData[c][i];
                        }
                    }
                    
                    // Allocate memory for output data
                    const outputPtrs = this.rubberBandModule._malloc(channels * 4); // Array of pointers
                    const outputChannelPtrs = [];
                    
                    for (let c = 0; c < channels; c++) {
                        const channelPtr = this.rubberBandModule._malloc(outputLength * 4); // 4 bytes per float
                        outputChannelPtrs.push(channelPtr);
                        this.rubberBandModule.HEAPU32[outputPtrs / 4 + c] = channelPtr;
                    }
                    
                    console.log('Processing audio with Rubber Band...');
                    
                    try {
                        // Process the audio
                        this.rubberBandModule._rubberband_process(stretcher, inputPtrs, inputLength, 1);
                        
                        // Get available output samples
                        const available = this.rubberBandModule._rubberband_available(stretcher);
                        console.log(`Available output samples: ${available}`);
                        
                        if (available > 0) {
                            // Retrieve the processed audio
                            const retrieved = this.rubberBandModule._rubberband_retrieve(stretcher, outputPtrs, Math.min(available, outputLength));
                            console.log(`Retrieved samples: ${retrieved}`);
                            
                            if (retrieved > 0) {
                                console.log('Creating output AudioBuffer...');
                                
                                // Create output AudioBuffer
                                const outputBuffer = this.audioContext.createBuffer(channels, retrieved, sampleRate);
                                
                                console.log('Copying processed data from WASM memory...');
                                
                                // Copy output data from WASM memory
                                for (let c = 0; c < channels; c++) {
                                    try {
                                        const outputChannelData = outputBuffer.getChannelData(c);
                                        const channelPtr = outputChannelPtrs[c];
                                        
                                        console.log(`Copying channel ${c} data (${retrieved} samples)...`);
                                        
                                        for (let i = 0; i < retrieved; i++) {
                                            const sample = this.rubberBandModule.HEAPF32[channelPtr / 4 + i];
                                            
                                            // Validate sample value
                                            if (isNaN(sample) || !isFinite(sample)) {
                                                console.warn(`Invalid sample at channel ${c}, index ${i}: ${sample}`);
                                                outputChannelData[i] = 0;
                                            } else {
                                                // Clamp to valid audio range
                                                outputChannelData[i] = Math.max(-1, Math.min(1, sample));
                                            }
                                        }
                                        
                                        console.log(`Channel ${c} copied successfully`);
                                        
                                    } catch (channelError) {
                                        console.error(`Error copying channel ${c}:`, channelError);
                                        console.error('Channel error name:', channelError.name);
                                        console.error('Channel error message:', channelError.message);
                                        console.error('Channel error stack:', channelError.stack);
                                        throw channelError;
                                    }
                                }
                                
                                console.log('Time stretching completed successfully');
                                return outputBuffer;
                                
                            } else {
                                console.warn('No samples were retrieved from Rubber Band');
                                return null;
                            }
                        } else {
                            console.warn('No output samples available from Rubber Band');
                            return null;
                        }
                        
                    } finally {
                        // Clean up stretcher instance
                        console.log('Cleaning up Rubber Band stretcher...');
                        this.rubberBandModule._rubberband_delete(stretcher);
                        
                        // Clean up allocated memory
                        console.log('Cleaning up WASM memory...');
                        
                        // Free input channel memory
                        for (let c = 0; c < inputChannelPtrs.length; c++) {
                            this.rubberBandModule._free(inputChannelPtrs[c]);
                        }
                        this.rubberBandModule._free(inputPtrs);
                        
                        // Free output channel memory
                        for (let c = 0; c < outputChannelPtrs.length; c++) {
                            this.rubberBandModule._free(outputChannelPtrs[c]);
                        }
                        this.rubberBandModule._free(outputPtrs);
                        
                        console.log('Memory cleanup completed');
                    }
                    
                } catch (error) {
                    console.error('Error in processTimeStretching:');
                    console.error('Error name:', error.name);
                    console.error('Error message:', error.message);
                    console.error('Error stack:', error.stack);
                    console.error('Error toString:', error.toString());
                    
                    // Additional debugging info
                    console.error('AudioContext state:', this.audioContext ? this.audioContext.state : 'null');
                    console.error('Original buffer info:', {
                        channels: audioBuffer.numberOfChannels,
                        length: audioBuffer.length,
                        sampleRate: audioBuffer.sampleRate,
                        duration: audioBuffer.duration
                    });
                    
                    return null;
                }
            }

            audioBufferToWav(audioBuffer) {
                const length = audioBuffer.length;
                const numberOfChannels = audioBuffer.numberOfChannels;
                const sampleRate = audioBuffer.sampleRate;
                const format = 1; // PCM
                const bitDepth = 16;
                
                const bytesPerSample = bitDepth / 8;
                const blockAlign = numberOfChannels * bytesPerSample;
                const byteRate = sampleRate * blockAlign;
                const dataSize = length * blockAlign;
                const headerSize = 44;
                const fileSize = headerSize + dataSize - 8;
                
                const buffer = new ArrayBuffer(headerSize + dataSize);
                const view = new DataView(buffer);
                
                // WAV header
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };
                
                writeString(0, 'RIFF');
                view.setUint32(4, fileSize, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true); // fmt chunk size
                view.setUint16(20, format, true);
                view.setUint16(22, numberOfChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, byteRate, true);
                view.setUint16(32, blockAlign, true);
                view.setUint16(34, bitDepth, true);
                writeString(36, 'data');
                view.setUint32(40, dataSize, true);
                
                // Convert audio data
                let offset = headerSize;
                for (let i = 0; i < length; i++) {
                    for (let channel = 0; channel < numberOfChannels; channel++) {
                        const sample = Math.max(-1, Math.min(1, audioBuffer.getChannelData(channel)[i]));
                        view.setInt16(offset, sample * 0x7FFF, true);
                        offset += 2;
                    }
                }
                
                return new Uint8Array(buffer);
            }
        }

        // File input handler
        document.getElementById('audioFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                
                // Update status
                const status = document.getElementById('status');
                status.innerHTML = `<div class="status success">Loading: ${file.name}</div>`;
                
                // Clear previous player
                const container = document.getElementById('audioPlayerContainer');
                container.innerHTML = '';
                
                // Create new player
                const config = {
                    src: url,
                    width: 500
                };
                
                const player = new AudioWaveformPlayerComponent(container, config, mockApp);
                player.render().then(() => {
                    status.innerHTML = `<div class="status success">✅ Loaded: ${file.name}</div>`;
                    console.log('Audio player loaded successfully');
                }).catch(error => {
                    status.innerHTML = `<div class="status error">❌ Error loading: ${error.message}</div>`;
                    console.error('Error loading audio player:', error);
                });
            }
        });

        // Initial message
        console.log('🎵 Audio Waveform Player Test initialized');
        console.log('Select an audio file to begin testing...');
    </script>
</body>
</html>
